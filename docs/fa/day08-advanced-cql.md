# روز هشتم - ویژگی‌های پیشرفته CQL در آپاچی کاساندرا

![Cassandra Logo](https://img.shields.io/badge/Apache%20Cassandra-1287B1?style=flat&logo=apache-cassandra&logoColor=white)  
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)  
[![GitHub stars](https://img.shields.io/github/stars/mrkeshi/cassandra-journey-10days?style=social)](https://github.com/mrkeshi/cassandra-journey-10days)

به **روز هشتم** از سفر یادگیری آپاچی کاساندرا خوش آمدید! 🎉 امروز به بررسی **ویژگی‌های پیشرفته CQL** می‌پردازیم که به شما امکان ساخت اپلیکیشن‌های بلادرنگ، منعطف و مقاوم در برابر خطا را می‌دهند. این ابزارها قدرتمند هستند، اما نیاز به درک عمیق دارند تا از اشتباهات رایج مانند استفاده نادرست از دستورات `BATCH` یا وابستگی بیش از حد به ایندکس‌های ثانویه جلوگیری شود. با تسلط بر این ویژگی‌ها، می‌توانید پتانسیل کامل کاساندرا را برای مدیریت موارد استفاده پیچیده با دقت و کارایی بالا آزاد کنید. 🚀

در این راهنما، ما:  
- ویژگی‌های پیشرفته CQL مانند دستورات `BATCH`، تراکنش‌های سبک (LWT)، نمای مادی‌شده، انواع داده تعریف‌شده توسط کاربر (UDT)، توابع تعریف‌شده توسط کاربر (UDF) و پشتیبانی از JSON را بررسی می‌کنیم 📝  
- مثال‌های کاربردی متناسب با یک اپلیکیشن شبکه اجتماعی ارائه می‌دهیم 📱  
- بهترین روش‌ها و اشتباهات رایج را که باید از آن‌ها اجتناب کنید، برجسته می‌کنیم ⚠️  
- نکته‌ای اضافی درباره حذف ایمن جدول‌ها و کی‌اسپیس‌ها ارائه می‌دهیم 🛠️  

> **توجه**: فراموش کردم زودتر ذکر کنم، اما حذف جدول‌ها و کی‌اسپیس‌ها عملیاتی حساس است که نیاز به دقت دارد. برای حذف یک جدول، از دستور `DROP TABLE keyspace_name.table_name;` استفاده کنید. برای حذف یک کی‌اسپیس کامل، از `DROP KEYSPACE keyspace_name;` استفاده کنید. همیشه مطمئن شوید که از داده‌ها نسخه پشتیبان تهیه کرده‌اید یا مطمئن هستید که دیگر به آن‌ها نیاز ندارید، زیرا این عملیات غیرقابل بازگشت هستند!

## دستورات دسته‌ای (Batch Statements) – اجرای چند دستور با هم

### دستورات دسته‌ای چیست؟  
دستورات دسته‌ای به شما امکان می‌دهند چندین عملیات `INSERT`، `UPDATE` یا `DELETE` را به‌صورت یک واحد منطقی اجرا کنید. این دستورات برای گروه‌بندی عملیات نوشتاری مرتبط، به‌ویژه زمانی که روی یک کلید پارتیشن یکسان اعمال می‌شوند، مفید هستند.

### انواع دسته‌ها  
- **دسته ثبت‌شده (Logged Batch)**: تضمین اتمیک بودن (همه عملیات با هم موفق یا ناموفق می‌شوند) را دارد، اما به دلیل سربار هماهنگی کندتر است. برای عملیات‌هایی که نیاز به سازگاری دارند استفاده کنید.  
- **دسته ثبت‌نشده (Unlogged Batch)**: سریع‌تر است زیرا مرحله هماهنگی را نادیده می‌گیرد، اما اتمیک بودن را تضمین نمی‌کند. برای عملیات‌های حساس به عملکرد مناسب است.  
- **دسته شمارشگر (Counter Batch)**: مخصوص جداول با ستون‌های شمارشگر، برای به‌روزرسانی اتمیک شمارشگرها استفاده می‌شود.

### مثال: اپلیکیشن شبکه اجتماعی  
تصور کنید در یک اپلیکیشن شبکه اجتماعی، کاربر یک به‌روزرسانی وضعیت ارسال می‌کند و ما باید همزمان پروفایل کاربر و جدول زمانی او را به‌روزرسانی کنیم.

```sql
BEGIN UNLOGGED BATCH
  INSERT INTO posts (user_id, post_id, content, created_at) 
  VALUES (1, uuid(), 'سلام دنیا!', '2025-08-05T12:00:00');
  UPDATE users SET post_count = post_count + 1 WHERE user_id = 1;
APPLY BATCH;
```

### بهترین روش‌ها  
- **استفاده برای کلید پارتیشن یکسان**: دسته‌ها زمانی کارآمد هستند که عملیات‌ها روی یک کلید پارتیشن یکسان انجام شوند تا از اضافه‌بار روی گره هماهنگ‌کننده جلوگیری شود.  
- **اجتناب از دسته‌های بزرگ**: دسته‌های بزرگ می‌توانند به خوشه فشار وارد کنند. تعداد عملیات‌ها را محدود کنید (مثلاً کمتر از 10).  
- **انتخاب دسته ثبت‌نشده برای عملکرد**: از دسته‌های ثبت‌نشده استفاده کنید مگر اینکه اتمیک بودن ضروری باشد.

### اشتباه رایج  
استفاده از دسته برای عملیات‌هایی که روی کلیدهای پارتیشن مختلف انجام می‌شوند می‌تواند گره هماهنگ‌کننده را تحت فشار قرار دهد و عملکرد را کاهش دهد. به عنوان مثال:  
```sql
BEGIN BATCH
  INSERT INTO posts (user_id, post_id, content) VALUES (1, uuid(), 'پست 1');
  INSERT INTO posts (user_id, post_id, content) VALUES (2, uuid(), 'پست 2');
APPLY BATCH;
```  
این کار به دلیل پوشش چندین پارتیشن ناکارآمد است. در عوض، این عملیات‌ها را به‌صورت جداگانه اجرا کنید.

## تراکنش‌های سبک (LWT) – عملیات شرطی

### تراکنش‌های سبک چیست؟  
تراکنش‌های سبک (LWT) امکان انجام عملیات شرطی را فراهم می‌کنند، به‌طوری که تغییرات تنها در صورتی اعمال می‌شوند که شرط خاصی برقرار باشد (مثلاً "مقایسه و تنظیم"). این تراکنش‌ها از پروتکل Paxos برای سازگاری استفاده می‌کنند، بنابراین کندتر هستند اما اتمیک و خطی‌سازی‌پذیر هستند.

### مثال: جلوگیری از نام‌های کاربری تکراری  
در اپلیکیشن شبکه اجتماعی خود، می‌خواهیم اطمینان حاصل کنیم که نام‌های کاربری در هنگام ثبت‌نام یکتا باشند.

```sql
INSERT INTO users (user_id, username, email) 
VALUES (1, 'ali123', 'ali@example.com') 
IF NOT EXISTS;
```

اگر کاربری با `user_id = 1` از قبل وجود داشته باشد، عملیات ناموفق خواهد بود و نتیجه ممکن است به این صورت باشد:  
```
[applied] | user_id | username | email
----------|---------|----------|----------------
 false    | 1       | ali123   | ali@example.com
```

### مثال: به‌روزرسانی شرطی  
فرض کنید می‌خواهیم پروفایل کاربر را تنها در صورتی به‌روزرسانی کنیم که ایمیل او تغییر نکرده باشد.

```sql
UPDATE users 
SET username = 'ali_new' 
WHERE user_id = 1 
IF email = 'ali@example.com';
```

اگر ایمیل مطابقت نداشته باشد، به‌روزرسانی ناموفق خواهد بود:  
```
[applied] | email
----------|----------------
 false    | wrong@email.com
```

### ویژگی‌های کلیدی  
| ویژگی | نوشتن معمولی | LWT |  
|-------|---------------|-----|  
| **شرط** | ندارد، همیشه اجرا می‌شود | فقط در صورت برقراری شرط اجرا می‌شود |  
| **اتمیک بودن** | خیر | بله (از پروتکل Paxos استفاده می‌کند) |  
| **سرعت** | سریع ⚡ | کندتر 🐢 به دلیل هماهنگی |  
| **مورد استفاده** | به‌روزرسانی‌های ساده | کنترل هم‌زمانی، محدودیت‌های یکتا |  
| **فشار روی خوشه** | کم | زیاد |

### چه زمانی از LWT استفاده کنیم؟  
- **استفاده کنید وقتی**: نیاز به جلوگیری از شرایط رقابتی، اطمینان از یکتایی داده‌ها (مثلاً نام‌های کاربری) یا پیاده‌سازی قفل خوش‌بینانه دارید.  
- **اجتناب کنید وقتی**: عملکرد اولویت دارد یا شرایط خاصی لازم نیست.

## نمای مادی‌شده (Materialized Views) – نمای ثانویه از داده‌ها

### نمای مادی‌شده چیست؟  
نمای مادی‌شده یک جدول ثانویه با کلید اصلی یا ترتیب مرتب‌سازی متفاوت ایجاد می‌کند که به‌طور خودکار از جدول اصلی پر می‌شود. این ابزار برای پشتیبانی از الگوهای کوئری اضافی بدون نیاز به تکثیر دستی داده‌ها مفید است.

### مثال: کوئری کاربران بر اساس ایمیل  
در اپلیکیشن شبکه اجتماعی، می‌خواهیم کاربران را بر اساس ایمیل به جای `user_id` کوئری کنیم.

```sql
CREATE MATERIALIZED VIEW users_by_email AS
  SELECT user_id, username, email 
  FROM users
  WHERE email IS NOT NULL AND user_id IS NOT NULL
  PRIMARY KEY (email, user_id);
```

حالا می‌توانیم کوئری کنیم:  
```sql
SELECT * FROM users_by_email WHERE email = 'ali@example.com';
```

### هشدار  
در کاساندرا نسخه 4.0 و بالاتر، نمای مادی‌شده به دلیل مشکلات سازگاری منسوخ شده است. جایگزین‌های زیر را در نظر بگیرید:  
- **نرمال‌سازی معکوس (Denormalization)**: ایجاد جداول جداگانه با کلیدهای اصلی متفاوت.  
- **ایندکس‌های ثانویه**: برای ستون‌های با کاردینالیتی پایین.  
- **موتورهای جستجوی خارجی**: استفاده از Elasticsearch یا Solr برای کوئری‌های پیچیده.  
- **منطق در سطح اپلیکیشن**: ذخیره نتایج کوئری در لایه اپلیکیشن.

## انواع داده تعریف‌شده توسط کاربر (UDTs) – ساختار داده پیچیده

### UDT چیست؟  
UDTs به شما امکان می‌دهند ساختارهای داده پیچیده (مانند struct) را در یک ستون تعریف کنید و نیاز به ایجاد جداول جداگانه را کاهش دهید.

### مثال: ذخیره آدرس کاربران  
در اپلیکیشن شبکه اجتماعی، می‌خواهیم آدرس کاربر را به‌صورت یک شیء ساختاریافته ذخیره کنیم.

```sql
CREATE TYPE address (
  street text,
  city text,
  zip int
);

CREATE TABLE users (
  user_id int PRIMARY KEY,
  username text,
  addr address
);

INSERT INTO users (user_id, username, addr)
VALUES (1, 'ali123', {street: 'ولیعصر', city: 'تهران', zip: 12345});
```

### بهترین روش‌ها  
- از UDT برای داده‌های مرتبط منطقی (مثلاً آدرس‌ها، مختصات) استفاده کنید.  
- از UDTهای عمیقاً تودرتو اجتناب کنید، زیرا می‌توانند کوئری‌ها را پیچیده کنند.

## توابع و تجمیع‌های تعریف‌شده توسط کاربر (UDFs و Aggregates) – توابع دلخواه

### UDF چیست؟  
UDFها به شما امکان می‌دهند توابع سفارشی را با استفاده از Java یا JavaScript بنویسید تا قابلیت‌های CQL را گسترش دهید. تجمیع‌ها توابع تجمیعی سفارشی هستند.

### مثال: بررسی زوج بودن تعداد پست‌ها  
در اپلیکیشن شبکه اجتماعی، می‌خواهیم بررسی کنیم که آیا تعداد پست‌های کاربر زوج است یا خیر.

```sql
CREATE FUNCTION is_even(n int)
RETURNS NULL ON NULL INPUT
RETURNS boolean
LANGUAGE java
AS 'return (n % 2) == 0;';

SELECT user_id, post_count, is_even(post_count) AS is_even 
FROM users;
```

### مثال: محاسبه طول نام کاربری  
طول نام کاربری را محاسبه کنید.

```sql
CREATE FUNCTION string_length(s text)
RETURNS NULL ON NULL INPUT
RETURNS int
LANGUAGE java
AS 'return s.length();';

SELECT username, string_length(username) AS name_length 
FROM users;
```

### هشدار  
UDFها می‌توانند عملکرد را تحت تأثیر قرار دهند و بهتر است در محیط‌های محلی یا آزمایشی استفاده شوند. در محیط‌های تولیدی با احتیاط استفاده کنید.

## پشتیبانی از JSON – ورودی/خروجی JSON

### پشتیبانی از JSON چیست؟  
کاساندرا امکان درج و بازیابی داده‌ها به فرمت JSON را فراهم می‌کند و یکپارچگی با اپلیکیشن‌های مدرن را ساده‌تر می‌کند.

### مثال: درج یک پست  
در اپلیکیشن شبکه اجتماعی، یک پست را با استفاده از JSON درج کنید.

```sql
INSERT INTO posts JSON 
'{"user_id": 2, "post_id": "uuid()", "content": "عاشق کاساندرا هستم!", "created_at": "2025-08-05T12:00:00"}';
```

### مثال: بازیابی به‌صورت JSON  
داده‌های کاربر را به‌صورت JSON بازیابی کنید.

```sql
SELECT JSON user_id, username, email FROM users WHERE user_id = 1;
```

### بهترین روش‌ها  
- از JSON برای نمونه‌سازی سریع یا هنگام یکپارچگی با APIهای مبتنی بر JSON استفاده کنید.  
- برای کوئری‌های با عملکرد بالا از JSON اجتناب کنید، زیرا تجزیه JSON سربار ایجاد می‌کند.

## بهترین روش‌ها و اشتباهات رایج

### بهترین روش‌ها  
- **استفاده هوشمندانه از دسته‌ها** 📦: از دسته‌های ثبت‌نشده برای عملکرد بهتر استفاده کنید و به عملیات‌های یک پارتیشن محدود کنید.  
- **استفاده محدود از LWT** 🔒: برای سناریوهایی که نیاز به کنترل هم‌زمانی یا یکتایی دارند رزرو کنید.  
- **اجتناب از استفاده بیش از حد از نمای مادی‌شده** 📊: برای کوئری‌های پیچیده، نرمال‌سازی معکوس یا موتورهای جستجوی خارجی را در نظر بگیرید.  
- **استفاده از UDT برای ساختار** 🛠️: از UDT برای مدل‌سازی داده‌های مرتبط و پیچیده استفاده کنید.  
- **آزمایش UDF در محیط محلی** 🧪: UDFها را با احتیاط به کار ببرید، زیرا می‌توانند عملکرد را تحت تأثیر قرار دهند.  
- **اعتبارسنجی داده‌های JSON** 📜: مطمئن شوید ورودی‌های JSON با ساختار جدول مطابقت دارند تا از خطاها جلوگیری شود.

### اشتباهات رایج  
- **اضافه‌بار با دسته‌ها** ⚠️: از دسته‌ها برای پارتیشن‌های متعدد استفاده نکنید.  
- **استفاده بیش از حد از LWT** 🚨: برای به‌روزرسانی‌های ساده از LWT استفاده نکنید، زیرا منابع زیادی مصرف می‌کند.  
- **نادیده گرفتن محدودیت‌های نمای مادی‌شده** 🚫: به مشکلات سازگاری در نسخه‌های جدید کاساندرا توجه کنید.  
- **UDFهای پیچیده در محیط تولیدی** 🛑: UDFها می‌توانند عملکرد را کاهش دهند؛ به‌طور کامل آزمایش کنید.

## نتیجه‌گیری  
امروز ویژگی‌های پیشرفته CQL را بررسی کردیم که آپاچی کاساندرا را به ابزاری قدرتمند برای ساخت اپلیکیشن‌های مقیاس‌پذیر و بلادرنگ تبدیل می‌کنند. با درک دستورات `BATCH`، تراکنش‌های سبک، نمای مادی‌شده، UDTها، UDFها و پشتیبانی از JSON، شما آماده هستید تا موارد استفاده پیچیده را در اپلیکیشن شبکه اجتماعی یا هر پروژه دیگری که با کاساندرا کار می‌کند مدیریت کنید. همیشه تعادل بین عملکرد و سازگاری را حفظ کنید و از اشتباهات رایج اجتناب کنید تا خوشه شما به‌خوبی کار کند. 🚀

