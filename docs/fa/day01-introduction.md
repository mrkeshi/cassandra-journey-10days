# 🚀 شروع کار با آپاچی کاساندرا – مبانی و معماری

خوش آمدید! این راهنمای مقدماتی به شما کمک می‌کند تا با **آپاچی کاساندرا** آشنا شوید — یک دیتابیس NoSQL توزیع‌شده و قدرتمند که برای مدیریت حجم بسیار زیادی از داده‌ها با قابلیت دسترسی بالا و مقیاس‌پذیری طراحی شده است.

اگر تا به حال تعجب کرده‌اید که پلتفرم‌هایی مثل **Netflix**، **Reddit** یا **Instagram** چطور داده‌های عظیم‌شان را بدون قطعی مدیریت می‌کنند، کاساندرا یکی از پاسخ‌هاست.

---

## 🎯 هدف

هدف ساخت یک سیستم **توزیع‌شده و مقیاس‌پذیر** است که بتواند حجم عظیمی از داده‌های ساختارمند را ذخیره کند. هر ردیف با یک کلید یکتا ایندکس می‌شود و هر ردیف می‌تواند **تعداد نامحدودی ستون** داشته باشد.

---

## 🧠 آپاچی کاساندرا چیست؟

**آپاچی کاساندرا** یک دیتابیس NoSQL متن‌باز است که برای کارایی و اطمینان بالا طراحی شده است. ابتدا در **سال ۲۰۰۷ در فیسبوک** برای جستجوی صندوق ورودی ساخته شد و سپس به پروژه‌ای در بنیاد آپاچی تبدیل شد.

کاساندرا ترکیبی از بهترین ایده‌هاست از:

- **Amazon Dynamo** (برای ذخیره کلید-مقدار توزیع‌شده)  
- **Google BigTable** (برای مدل داده ستونی)

### 🏗️ به زبان ساده:

کاساندرا مانند یک صفحه گسترده عظیم و غیرمتمرکز است که:

- هر ردیف کلید یکتا دارد  
- هر ردیف می‌تواند ستون‌های متفاوتی داشته باشد  
- داده‌ها به صورت خودکار روی چندین ماشین توزیع می‌شوند  
- هیچ نقطه شکست واحدی وجود ندارد

---

## ⚙️ کاساندرا چگونه کار می‌کند؟

- **غیرمتمرکز**: تمام نودها برابرند، نود اصلی یا رهبر وجود ندارد.  
- **قابل مقیاس**: با افزودن نودهای بیشتر، عملکرد بهتر می‌شود.  
- **دسترس‌پذیر**: سیستم حتی اگر بعضی نودها خراب شوند باز کار می‌کند.  
- **سازگاری قابل تنظیم**: می‌توانید بین سازگاری سریع اما نه چندان قوی و سازگاری کندتر اما مطمئن‌تر انتخاب کنید.

> کاساندرا طبق [نظریه CAP](https://fa.wikipedia.org/wiki/%D9%86%D8%B8%D8%B1%DB%8C%D9%87_CAP) یک سیستم **AP** (دسترس‌پذیر و مقاوم در برابر قطعی شبکه) است.

---

## 🧰 اصطلاحات رایج کاساندرا

| اصطلاح       | معنی                                                       |
|--------------|------------------------------------------------------------|
| **نود (Node)**      | یک ماشین (فیزیکی، ابری یا داکر) که کاساندرا روی آن اجرا می‌شود |
| **کلاستر (Cluster)** | گروهی از نودهای کاساندرا که به هم متصل‌اند               |
| **کی‌اسپیس (Keyspace)** | مانند یک دیتابیس که چندین جدول را در بر می‌گیرد           |
| **جدول (Table)**    | مانند جدول در SQL، شامل ردیف‌ها                             |
| **ردیف (Row)**      | شناسایی شده توسط کلید اصلی؛ شامل ستون‌های متعدد           |
| **ستون (Column)**   | یک مقدار داده کلید-مقدار                                   |

---

## 📦 موارد کاربرد کاساندرا

کاساندرا در برنامه‌های توزیع‌شده و سنگین نوشتن بلادرنگ عالی است. چند مثال واقعی:

- **Reddit/Digg**: ذخیره داده کاربران با دسترسی بالا  
- **اینترنت اشیاء (IoT)**: جمع‌آوری و تحلیل داده‌های حسگر  
- **لاگ‌برداری**: ذخیره داده‌های سری زمانی برای مانیتورینگ  
- **اپلیکیشن‌های اجتماعی**: پیام‌رسانی، فید خبری، موتورهای پیشنهاد

---

## 🔍 چرا کاساندرا؟

فرض کنید سیستمی می‌سازید که:

- باید میلیاردها داده حسگر در روز ذخیره کند  
- قطعی غیرقابل قبول است  
- نوشتن سریع داده اهمیت دارد  
- همیشه به سازگاری قوی نیاز ندارد

کاساندرا انتخاب مناسبی است.

---

## 🧱 نمای کلی معماری

- داده با استفاده از هش توزیع شده بین نودها تقسیم می‌شود  
- هیچ هماهنگ‌کننده مرکزی وجود ندارد؛ هر نود می‌تواند عملیات خواندن/نوشتن را انجام دهد  
- داده‌ها تکثیر می‌شوند تا ایمنی و دسترس‌پذیری تضمین شود

جزئیات بیشتر مثل **مم‌تیبل‌ها، SSTableها، کمپکشن** و **hinted handoff** در درس‌های بعدی بررسی خواهد شد.

---

## ⚠️ هشدار

مطالب آموزشی و کلی هستند و به نسخه خاصی از کاساندرا وابسته نیستند. هدف درک کلی نحوه کار کاساندرا است.

---

## 🧠 نکته

اگر با سیستم‌های توزیع‌شده آشنایی ندارید، کاساندرا را به یک **کتابخانه هوشمند** تشبیه کنید:

- کتاب‌ها (داده‌ها) در شعب مختلف (نودها) نگهداری می‌شوند  
- هر شعبه می‌تواند خدمات دهد  
- اگر یک شعبه بسته باشد، بقیه به شما کمک می‌کنند  
- کتاب‌ها در شعب مختلف کپی می‌شوند تا امن بمانند

---

## 🗝️ کلید اصلی (Primary Key)

کلید اصلی هر ردیف را یکتا می‌کند و دو بخش دارد:

- **کلید پارتیشن (Partition Key):** مشخص می‌کند داده روی کدام نود ذخیره شود  
- **کلید خوشه‌ای (Clustering Key):** ترتیب داده‌ها داخل نود را تعیین می‌کند

**مثال:**

``` PRIMARY KEY (city_id, employee_id) ```

city_id → کلید پارتیشن

employee_id → کلید خوشه‌ای

همه ردیف‌های با city_id مشابه روی یک نود قرار می‌گیرند؛ داخل آن نود بر اساس employee_id مرتب می‌شوند.
# 🚀 شروع کار با Apache Cassandra – مفاهیم پیشرفته

---

## 🔄 پارتیشنر (Partitioner)

**پارتیشنر** تصمیم می‌گیرد داده‌ها کجا ذخیره شوند با استفاده از تابع هش.

- پیش‌فرض: `Murmur3`  
- خروجی هش تعیین می‌کند داده روی کدام قسمت از **حلقه هش سازگار (Consistent Hash Ring)** قرار می‌گیرد  
- پس از انتخاب پارتیشنر، **نمی‌توان آن را تغییر داد**

### مثال:

```INSERT INTO employees (city_id, employee_id, name)  VALUES ('nyc', 101, 'Alice'); ```
'nyc' با Murmur3 هش می‌شود

خروجی هش به نود ۲ اشاره می‌کند → داده به نود ۲ می‌رود

# راهنمای کاساندرا (Cassandra Guide)

---

## 👤 نود هماهنگ‌کننده (Coordinator Node)

- نودی که درخواست کلاینت را دریافت می‌کند.  
- درخواست‌ها را به نودهای صحیح بر اساس هش و تکرار ارسال می‌کند.  
- هر نود می‌تواند نقش **هماهنگ‌کننده** را داشته باشد.

---

## 📦 تکرار داده (Replication)

کاساندرا داده‌ها را روی چندین نود تکرار می‌کند.

### 🔸 اصطلاحات

- **عامل تکرار (Replication Factor - RF):** تعداد نسخه‌های هر ردیف.  
- **استراتژی تکرار (Replication Strategy):** نحوه انتخاب نودهای نسخه‌ها.

### ➤ مثال:

اگر `RF = 3` → داده روی ۳ نود مختلف ذخیره می‌شود.

### 🔹 استراتژی ساده (SimpleStrategy) – دیتاسنتر تکی

- نسخه اول روی نود هش شده  
- نسخه‌های بعدی روی ۲ نود بعدی به صورت ساعتگرد روی حلقه

### 🔹 استراتژی توپولوژی شبکه (NetworkTopologyStrategy) – دیتاسنترهای چندگانه

- تعریف RFهای متفاوت برای هر دیتاسنتر  
- جلوگیری از قرار گرفتن نسخه‌ها روی یک **رک** (rack)

---

## سطوح سازگاری (Consistency Levels)

**سطح سازگاری** = حداقل تعداد نودهایی که باید برای موفقیت‌آمیز بودن خواندن/نوشتن پاسخ دهند.

کاساندرا دارای **سازگاری قابل تنظیم** است.

### 🔸 سطوح سازگاری نوشتن

| سطح          | توضیح                                   |
|--------------|---------------------------------------|
| ONE, TWO, THREE | ۱، ۲ یا ۳ نسخه باید تأیید کنند          |
| QUORUM       | اکثریت (مثلاً RF = 3 → ۲ نود)           |
| ALL          | همه نسخه‌ها باید پاسخ دهند (قوی‌ترین)    |
| ANY          | ۱ نود یا hint کافی است (ضعیف‌ترین)       |
| LOCAL_QUORUM | اکثریت در همان دیتاسنتر                  |
| EACH_QUORUM  | اکثریت در هر دیتاسنتر                     |

### ➤ مثال (RF = 3، سازگاری = QUORUM):

- ۲ از ۳ نود باید تأیید کنند  
- اگر ۲ نود پاسخ دهند → ✅ موفق  
- اگر فقط ۱ نود پاسخ دهد → ❌ شکست

---

## 📝 Hinted Handoff (بازپخش یادداشت)

وقتی یک نسخه **down** است، کاساندرا می‌تواند یک **یادداشت (hint)** روی نود دیگری ذخیره کند تا بعداً آن را بازپخش کند.

### ➤ مثال (RF = 3، ۱ نود down، سازگاری = QUORUM):

- هماهنگ‌کننده روی ۲ نود موجود موفقیت‌آمیز می‌نویسد ✅  
- یادداشتی برای نود سوم (down) ذخیره می‌کند  
- وقتی نود سوم آنلاین شود → هماهنگ‌کننده یادداشت را بازپخش می‌کند و داده‌ها همگام‌سازی می‌شوند

### ⚠️ نکات مهم

- یادداشت‌ها به طور پیش‌فرض ۳ ساعت نگهداری می‌شوند.  
- بعد از ۳ ساعت، اگر نود هنوز down باشد ممکن است داده‌ها را از دست بدهد.  
- کاساندرا هنگام خواندن این مشکل را با **Read Repair** جبران می‌کند (بعداً توضیح داده می‌شود).

---

## ❌ اجتناب از استفاده از سطح سازگاری ‘ANY’ برای نوشتن

- نوشتن حتی اگر **تمام نسخه‌ها down باشند** موفقیت‌آمیز است چون یادداشت ذخیره می‌کند.  
- اما داده هنوز روی هیچ نسخه‌ای به طور کامل نوشته نشده است.  
- اگر هماهنگ‌کننده قبل از بازپخش یادداشت‌ها کرش کند → ممکن است داده از دست برود.

### 🔺 فقط در صورتی از `ANY` استفاده کنید که ریسک آن را پذیرفته‌اید.

---

## 📖 سطوح سازگاری خواندن در کاساندرا

سطوح سازگاری برای خواندن مشخص می‌کند چند نسخه باید پاسخ دهند تا داده برگردانده شود.

### ➤ مثال:

اگر `RF = 3` و سطح سازگاری خواندن `QUORUM` باشد:

- هماهنگ‌کننده منتظر پاسخ حداقل ۲ نود می‌ماند.  
- اگر ۲ نود پاسخ دهند، داده به کلاینت برمی‌گردد.  
- اگر کمتر از ۲ پاسخ دهند → خواندن شکست می‌خورد.

---

## 🔐 رسیدن به سازگاری قوی (Strong Consistency)

کاساندرا سازگاری قوی را تضمین می‌کند اگر:  
`R + W > RF`  

که در آن:  
- **R** = تعداد نودهای پاسخ‌دهنده به خواندن  
- **W** = تعداد نودهای تأییدکننده نوشتن  
- **RF** = عامل تکرار

### ➤ مثال 1: سازگاری قوی با RF=3

- سازگاری نوشتن = QUORUM (W = 2)  
- سازگاری خواندن = QUORUM (R = 2)  
- چون ۲ + ۲ > ۳ → خواندن همیشه جدیدترین داده را نشان می‌دهد.

### ➤ مثال 2: حالت سازگاری ضعیف

- سازگاری نوشتن = ONE (W = 1)  
- سازگاری خواندن = ONE (R = 1)  
- ۱ + ۱ = ۲ ≤ ۳ → خواندن ممکن است داده‌های قدیمی را نشان دهد.

---

## 🕵️‍♂️ Snitch: بهینه‌سازی نزدیکی و سرعت نودها

**Snitch** به کاساندرا اطلاعات توپولوژی شبکه می‌دهد:

- مشخص می‌کند کدام نودها در کدام دیتاسنتر و رک هستند.  
- درخواست‌ها را به نزدیک‌ترین و سریع‌ترین نود هدایت می‌کند.  
- کمک می‌کند نسخه‌ها در رک‌های مختلف قرار بگیرند تا نقاط شکست کاهش یابند.

---

## ⚡ چطور کاساندرا خواندن انجام می‌دهد

1. هماهنگ‌کننده سریع‌ترین نسخه را انتخاب و درخواست کامل خواندن می‌فرستد.  
2. درخواست **digest** (چک‌سام) از سایر نسخه‌ها برای صحت داده می‌کند.  
3. اگر digestها برابر نباشند، داده کامل از همه نسخه‌ها خوانده می‌شود تا جدیدترین نسخه پیدا شود.  
4. جدیدترین داده به کلاینت برگردانده می‌شود.  
5. به صورت ناهمزمان **Read Repair** برای اصلاح نسخه‌های قدیمی آغاز می‌شود.

---

## 🔧 Read Repair: حفظ سازگاری داده‌ها

- نسخه‌های ناهمگام در طول خواندن اصلاح می‌شوند.  
- از timestamps برای تشخیص جدیدترین داده استفاده می‌کند.  
- به صورت احتمالی (مثلاً ۱۰٪ خواندن‌ها) اجرا می‌شود تا بار سیستم زیاد نشود.  
- به صورت ناهمزمان اجرا شده و باعث وقفه در پاسخ به کلاینت نمی‌شود.

### مثال

فرض کنید RF=3 و نودها: Node A، Node B و Node C.

1. یک به‌روزرسانی رخ می‌دهد:  
   داده روی Node A و Node B نوشته شده است.  
   Node C آفلاین بوده و به‌روزرسانی را دریافت نکرده است.

2. کلاینت خواندن با سازگاری QUORUM انجام می‌دهد:  
   هماهنگ‌کننده داده کامل را از Node A می‌گیرد.  
   digestها را از Node B و Node C می‌گیرد.

3. ناسازگاری تشخیص داده می‌شود:  
   digest Node C با A و B متفاوت است.

4. Read Repair اجرا می‌شود:  
   هماهنگ‌کننده جدیدترین داده را از A یا B می‌گیرد.  
   داده به Node C ارسال می‌شود تا اصلاح شود.  
   کلاینت جدیدترین داده را دریافت می‌کند.

---

## 🌐 پروتکل Gossip: همگام‌سازی وضعیت کلاستر

- نودها هر ثانیه با ۱ تا ۳ نود تصادفی وضعیت خود را تبادل می‌کنند.  
- از شماره‌های نسل برای تشخیص راه‌اندازی مجدد استفاده می‌کند.  
- Seed nodeها به نودهای جدید کمک می‌کنند به کلاستر ملحق شوند.  
- اطمینان می‌دهد همه نودها اطلاعات به‌روز دارند.

---

## ⏰ شناسایی خطا با Phi Accrual Failure Detector

- خطاهای نود را با سطوح شک تطبیقی شناسایی می‌کند (نه فقط زنده/مرده).  
- کاهش مثبت‌های کاذب ناشی از تأخیر شبکه.  
- به تدریج نودهای کند یا خراب را منزوی می‌کند.

---

## ✍️ روند نوشتن در کاساندرا

1. نوشتن ابتدا به **commit log** روی دیسک افزوده می‌شود (برای دوام داده).  
2. داده به **MemTable** (ساختار مرتب در حافظه) اضافه می‌شود.  
3. وقتی MemTable پر شد، به صورت یک **SSTable** غیرقابل تغییر روی دیسک ذخیره می‌شود.  
4. عملیات **compaction** دوره‌ای SSTableها را ادغام و بهینه می‌کند.

---

## 📂 Commit Log

- لاگ پیش‌نویس نوشته شده روی دیسک.  
- تضمین دوام داده در صورت کرش.  
- نوشتن تا کامل شدن Commit Log تأیید نمی‌شود.

---

## 🧠 MemTable

- ذخیره‌سازی موقت و در حافظه.  
- مرتب شده بر اساس کلید پارتیشن و ستون‌های خوشه‌ای.  
- خواندن و نوشتن سریع.  
- چندین MemTable وجود دارد هنگام فلش شدن.

---

## 💽 SSTables (جداول رشته‌ای مرتب)

- فایل‌های غیرقابل تغییر روی دیسک پس از فلش MemTable.  
- شامل پارتیشن‌ها و ردیف‌های مرتب شده.  
- به‌روزرسانی‌ها باعث ایجاد SSTable جدید می‌شوند؛ SSTableهای قدیمی پس از compaction حذف می‌شوند.

---

## 🗑️ Tombstones: حذف نرم

- حذف‌ها با **tombstone** علامت‌گذاری می‌شوند، نه حذف فوری.  
- tombstoneها پس از ~۱۰ روز (قابل تنظیم) منقضی می‌شوند.  
- در compaction حذف می‌شوند تا فضا آزاد شود.  
- tombstone زیاد باعث کندی خواندن و مصرف فضای بیشتر می‌شود.

---

## ⚡ خواندن داده در کاساندرا

1. چک کردن **Row Cache** برای ردیف‌های پر استفاده.  
2. در صورت عدم یافتن، چک کردن **Bloom filter** برای رد سریع SSTableهای بدون داده.  
3. استفاده از **Key Cache** برای یافتن مکان پارتیشن.  
4. جستجو در **Partition Index Summary** و **Partition Index** برای یافتن آفست داده.  
5. خواندن از MemTable و SSTableها برای دریافت جدیدترین نسخه.

---

## 🌀 Compaction

- ادغام چند SSTable به یکی.  
- حذف داده‌های قدیمی و tombstoneها.  
- کاهش تعداد SSTableهایی که باید خوانده شوند.  
- استراتژی‌ها:  
  - **SizeTiered** (پیش‌فرض، مناسب نوشتن زیاد)  
  - **Leveled** (بهینه‌شده برای خواندن)  
  - **TimeWindow** (مناسب داده‌های زمان‌محور)

---

## 🎯 مثال‌ها

### مثال 1: خواندن با سازگاری Quorum

- `RF = 3`، `W = 2`، `R = 2` (quorum)  
- نوشتن روی هر ۲ نود، خواندن از هر ۲ نود.  
- تضمین می‌کند `R + W > RF` → سازگاری قوی.

### مثال 2: سناریوی Tombstone

- داده روی Node A (که down است) حذف شده.  
- Node B هنوز داده را دارد.  
- tombstone تضمین می‌کند وقتی Node A بازیابی و همگام‌سازی شود، داده حذف شده باز نگردد.

---

