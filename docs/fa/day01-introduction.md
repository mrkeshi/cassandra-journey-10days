
# 🚀 شروع کار با آپاچی کاساندرا – مبانی و معماری
![Cassandra Logo](https://img.shields.io/badge/Apache%20Cassandra-1287B1?style=flat&logo=apache-cassandra&logoColor=white) 
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![GitHub stars](https://img.shields.io/github/stars/mrkeshi/cassandra-journey-10days?style=social)](https://github.com/mrkeshi/cassandra-journey-10days)

خوش آمدید! این راهنمای مقدماتی به شما کمک می‌کند تا با **آپاچی کاساندرا** آشنا شوید — یک دیتابیس NoSQL توزیع‌شده و قدرتمند که برای مدیریت حجم بسیار زیادی از داده‌ها با قابلیت دسترسی بالا و مقیاس‌پذیری طراحی شده است.
اگر تا به حال تعجب کرده‌اید که پلتفرم‌هایی مثل **Netflix**، **Reddit** یا **Instagram** چطور داده‌های عظیم‌شان را بدون قطعی مدیریت می‌کنند، کاساندرا یکی از پاسخ‌هاست.

---
## 🎯 هدف

هدف ساخت یک سیستم **توزیع‌شده و مقیاس‌پذیر** است که بتواند حجم عظیمی از داده‌های ساختارمند را ذخیره کند. هر ردیف با یک کلید یکتا ایندکس می‌شود و هر ردیف می‌تواند **تعداد نامحدودی ستون** داشته باشد.

---
## 🧠 آپاچی کاساندرا چیست؟
**آپاچی کاساندرا** یک دیتابیس NoSQL متن‌باز است که برای کارایی و اطمینان بالا طراحی شده است. ابتدا در **سال ۲۰۰۷ در فیسبوک** برای جستجوی صندوق ورودی ساخته شد و سپس به پروژه‌ای در بنیاد آپاچی تبدیل شد.
کاساندرا ترکیبی از بهترین ایده‌هاست از:
                                                                                                                                                                                   **Amazon Dynamo** (برای ذخیره کلید-مقدار توزیع‌شده) -
                                                                                                                                                                                       **Google BigTable** (برای مدل داده ستونی)  -
### 🏗️ به زبان ساده:
کاساندرا مانند یک صفحه گسترده عظیم و غیرمتمرکز است که:
- هر ردیف کلید یکتا دارد 
- هر ردیف می‌تواند ستون‌های متفاوتی داشته باشد 
- داده‌ها به صورت خودکار روی چندین ماشین توزیع می‌شوند 
- هیچ نقطه شکست واحدی وجود ندارد
---
## ⚙️ کاساندرا چگونه کار می‌کند؟
- **غیرمتمرکز**: تمام نودها برابرند، نود اصلی یا رهبر وجود ندارد. 
- **قابل مقیاس**: با افزودن نودهای بیشتر، عملکرد بهتر می‌شود. 
- **دسترس‌پذیر**: سیستم حتی اگر بعضی نودها خراب شوند باز کار می‌کند. 
- **سازگاری قابل تنظیم**: می‌توانید بین سازگاری سریع اما نه چندان قوی و سازگاری کندتر اما مطمئن‌تر انتخاب کنید.
> کاساندرا طبق [نظریه CAP](https://fa.wikipedia.org/wiki/%D9%86%D8%B8%D8%B1%DB%8C%D9%87_CAP) یک سیستم **AP** (دسترس‌پذیر و مقاوم در برابر قطعی شبکه) است.
---
## 🧰 اصطلاحات رایج کاساندرا
| اصطلاح | معنی |
|--------------|------------------------------------------------------------|
| **نود (Node)** | یک ماشین (فیزیکی، ابری یا داکر) که کاساندرا روی آن اجرا می‌شود |
| **کلاستر (Cluster)** | گروهی از نودهای کاساندرا که به هم متصل‌اند |
| **کی‌اسپیس (Keyspace)** | مانند یک دیتابیس که چندین جدول را در بر می‌گیرد |
| **جدول (Table)** | مانند جدول در SQL، شامل ردیف‌ها |
| **ردیف (Row)** | شناسایی شده توسط کلید اصلی؛ شامل ستون‌های متعدد |
| **ستون (Column)** | یک مقدار داده کلید-مقدار |
---
## 📦 موارد کاربرد کاساندرا
کاساندرا در برنامه‌های توزیع‌شده و سنگین نوشتن بلادرنگ عالی است. چند مثال واقعی:
- **اینترنت اشیاء (IoT)**: جمع‌آوری و تحلیل داده‌های حسگر 
- **لاگ‌برداری**: ذخیره داده‌های سری زمانی برای مانیتورینگ 
- **اپلیکیشن‌های اجتماعی**: پیام‌رسانی، فید خبری، موتورهای پیشنهاد
---
## 🔍 چرا کاساندرا؟
فرض کنید سیستمی می‌سازید که:
- باید میلیاردها داده حسگر در روز ذخیره کند 
- قطعی غیرقابل قبول است 
- نوشتن سریع داده اهمیت دارد 
- همیشه به سازگاری قوی نیاز ندارد
کاساندرا انتخاب مناسبی است.
---
## 🧱 نمای کلی معماری
- داده با استفاده از هش توزیع شده بین نودها تقسیم می‌شود 
- هیچ هماهنگ‌کننده مرکزی وجود ندارد؛ هر نود می‌تواند عملیات خواندن/نوشتن را انجام دهد 
- داده‌ها تکثیر می‌شوند تا ایمنی و دسترس‌پذیری تضمین شود
جزئیات بیشتر مثل **مم‌تیبل‌ها، SSTableها، کمپکشن** و **hinted handoff** در درس‌های بعدی بررسی خواهد شد.
---
## ⚠️ هشدار
مطالب آموزشی و کلی هستند و به نسخه خاصی از کاساندرا وابسته نیستند. هدف درک کلی نحوه کار کاساندرا است.
---
## 🧠 نکته
اگر با سیستم‌های توزیع‌شده آشنایی ندارید، کاساندرا را به یک **کتابخانه هوشمند** تشبیه کنید:
- کتاب‌ها (داده‌ها) در شعب مختلف (نودها) نگهداری می‌شوند 
- هر شعبه می‌تواند خدمات دهد 
- اگر یک شعبه بسته باشد، بقیه به شما کمک می‌کنند 
- کتاب‌ها در شعب مختلف کپی می‌شوند تا امن بمانند
---
## 🗝️ کلید اصلی (Primary Key)
کلید اصلی هر ردیف را یکتا می‌کند و دو بخش دارد:
- **کلید پارتیشن (Partition Key):** مشخص می‌کند داده روی کدام نود ذخیره شود 
- **کلید خوشه‌ای (Clustering Key):** ترتیب داده‌ها داخل نود را تعیین می‌کند
**مثال:**
``` PRIMARY KEY (city_id, employee_id) ```
city_id → کلید پارتیشن
employee_id → کلید خوشه‌ای
همه ردیف‌های با city_id مشابه روی یک نود قرار می‌گیرند؛ داخل آن نود بر اساس employee_id مرتب می‌شوند.
# 🚀 شروع کار با Apache Cassandra – مفاهیم پیشرفته
---
## 🔄 پارتیشنر (Partitioner)
**پارتیشنر** تصمیم می‌گیرد داده‌ها کجا ذخیره شوند با استفاده از تابع هش.
- پیش‌فرض: `Murmur3` 
- خروجی هش تعیین می‌کند داده روی کدام قسمت از **حلقه هش سازگار (Consistent Hash Ring)** قرار می‌گیرد 
- پس از انتخاب پارتیشنر، **نمی‌توان آن را تغییر داد**
### مثال:
                                                                                                                                      ```INSERT INTO employees (city_id, employee_id, name) VALUES ('nyc', 101, 'Alice'); ```
                                                                                                                                      'nyc' با Murmur3 هش می‌شود
خروجی هش به نود ۲ اشاره می‌کند → داده به نود ۲ می‌رود
# راهنمای کاساندرا (Cassandra Guide)
---
## 👤 نود هماهنگ‌کننده (Coordinator Node)
- نودی که درخواست کلاینت را دریافت می‌کند. 
- درخواست‌ها را به نودهای صحیح بر اساس هش و تکرار ارسال می‌کند. 
- هر نود می‌تواند نقش **هماهنگ‌کننده** را داشته باشد.
---
## 📦 تکرار داده (Replication)
کاساندرا داده‌ها را روی چندین نود تکرار می‌کند.
### 🔸 اصطلاحات
- **عامل تکرار (Replication Factor - RF):** تعداد نسخه‌های هر ردیف. 
- **استراتژی تکرار (Replication Strategy):** نحوه انتخاب نودهای نسخه‌ها.
### ➤ مثال:
اگر `RF = 3` → داده روی ۳ نود مختلف ذخیره می‌شود.
### 🔹 استراتژی ساده (SimpleStrategy) – دیتاسنتر تکی
- نسخه اول روی نود هش شده 
- نسخه‌های بعدی روی ۲ نود بعدی به صورت ساعتگرد روی حلقه
### 🔹 استراتژی توپولوژی شبکه (NetworkTopologyStrategy) – دیتاسنترهای چندگانه
- تعریف RFهای متفاوت برای هر دیتاسنتر 
- جلوگیری از قرار گرفتن نسخه‌ها روی یک **رک** (rack)
---
## سطوح سازگاری (Consistency Levels)
**سطح سازگاری** = حداقل تعداد نودهایی که باید برای موفقیت‌آمیز بودن خواندن/نوشتن پاسخ دهند.
کاساندرا دارای **سازگاری قابل تنظیم** است.
### 🔸 سطوح سازگاری نوشتن
| سطح | توضیح |
|--------------|---------------------------------------|
| ONE, TWO, THREE | ۱، ۲ یا ۳ نسخه باید تأیید کنند |
| QUORUM | اکثریت (مثلاً RF = 3 → ۲ نود) |
| ALL | همه نسخه‌ها باید پاسخ دهند (قوی‌ترین) |
| ANY | ۱ نود یا hint کافی است (ضعیف‌ترین) |
| LOCAL_QUORUM | اکثریت در همان دیتاسنتر |
| EACH_QUORUM | اکثریت در هر دیتاسنتر |
### ➤ مثال (RF = 3، سازگاری = QUORUM):
- ۲ از ۳ نود باید تأیید کنند 
- اگر ۲ نود پاسخ دهند → ✅ موفق 
- اگر فقط ۱ نود پاسخ دهد → ❌ شکست
---
  ## 📝 یادداشت- Hinted Handoff
وقتی یک نسخه **down** است، کاساندرا می‌تواند یک **یادداشت (hint)** روی نود دیگری ذخیره کند تا بعداً آن را بازپخش کند.
### ➤ مثال (RF = 3، ۱ نود down، سازگاری = QUORUM):
- هماهنگ‌کننده روی ۲ نود موجود موفقیت‌آمیز می‌نویسد ✅ 
- یادداشتی برای نود سوم (down) ذخیره می‌کند 
- وقتی نود سوم آنلاین شود → هماهنگ‌کننده یادداشت را بازپخش می‌کند و داده‌ها همگام‌سازی می‌شوند
### ⚠️ نکات مهم
- یادداشت‌ها به طور پیش‌فرض ۳ ساعت نگهداری می‌شوند. 
- بعد از ۳ ساعت، اگر نود هنوز down باشد ممکن است داده‌ها را از دست بدهد. 
- کاساندرا هنگام خواندن این مشکل را با **Read Repair** جبران می‌کند (بعداً توضیح داده می‌شود).
---
## ❌ اجتناب از استفاده از سطح سازگاری ‘ANY’ برای نوشتن
- نوشتن حتی اگر **تمام نسخه‌ها down باشند** موفقیت‌آمیز است چون یادداشت ذخیره می‌کند. 
- اما داده هنوز روی هیچ نسخه‌ای به طور کامل نوشته نشده است. 
- اگر هماهنگ‌کننده قبل از بازپخش یادداشت‌ها کرش کند → ممکن است داده از دست برود.
### 🔺 فقط در صورتی از `ANY` استفاده کنید که ریسک آن را پذیرفته‌اید.
---
## 📖 سطوح سازگاری خواندن در کاساندرا
سطوح سازگاری برای خواندن مشخص می‌کند چند نسخه باید پاسخ دهند تا داده برگردانده شود.
### ➤ مثال:
اگر `RF = 3` و سطح سازگاری خواندن `QUORUM` باشد:
- هماهنگ‌کننده منتظر پاسخ حداقل ۲ نود می‌ماند. 
- اگر ۲ نود پاسخ دهند، داده به کلاینت برمی‌گردد. 
- اگر کمتر از ۲ پاسخ دهند → خواندن شکست می‌خورد.
---
## 🔐 رسیدن به سازگاری قوی (Strong Consistency)
کاساندرا سازگاری قوی را تضمین می‌کند اگر: 
`R + W > RF` 
که در آن: 
- تعداد نودهای پاسخ‌دهنده به خواندن (**R**)
- تعداد نودهای تأییدکننده نوشتن (**W**)
- عامل تکرار (**RF**)

### ➤ مثال 1: سازگاری قوی با RF=3
- سازگاری نوشتن = QUORUM (W = 2) 
- سازگاری خواندن = QUORUM (R = 2) 
- چون ۲ + ۲ > ۳ → خواندن همیشه جدیدترین داده را نشان می‌دهد.
### ➤ مثال 2: حالت سازگاری ضعیف
- سازگاری نوشتن = ONE (W = 1) 
- سازگاری خواندن = ONE (R = 1) 
- ۱ + ۱ = ۲ ≤ ۳ → خواندن ممکن است داده‌های قدیمی را نشان دهد.
---
## 🕵️‍♂️ بهینه‌سازی نزدیکی و سرعت نودها (Snitch)
کاساندرا با استفاده از **Snitch** اطلاعات توپولوژی شبکه را دریافت می‌کند:
- مشخص می‌کند کدام نودها در کدام دیتاسنتر و رک هستند. 
- درخواست‌ها را به نزدیک‌ترین و سریع‌ترین نود هدایت می‌کند. 
- کمک می‌کند نسخه‌ها در رک‌های مختلف قرار بگیرند تا نقاط شکست کاهش یابند.
---
## ⚡ چطور کاساندرا خواندن انجام می‌دهد
۱. هماهنگ‌کننده سریع‌ترین نسخه را انتخاب و درخواست کامل خواندن می‌فرستد. 

۲. درخواست **digest** (چک‌سام) از سایر نسخه‌ها برای صحت داده می‌کند. 

۳. اگر digestها برابر نباشند، داده کامل از همه نسخه‌ها خوانده می‌شود تا جدیدترین نسخه پیدا شود. 

۴. جدیدترین داده به کلاینت برگردانده می‌شود. 

۵. به صورت ناهمزمان **Read Repair** برای اصلاح نسخه‌های قدیمی آغاز می‌شود.

---
## 🔧 حفظ سازگاری داده‌ها (Read Repair)
- نسخه‌های ناهمگام در طول خواندن اصلاح می‌شوند. 
- از timestamps برای تشخیص جدیدترین داده استفاده می‌کند. 
- به صورت احتمالی (مثلاً ۱۰٪ خواندن‌ها) اجرا می‌شود تا بار سیستم زیاد نشود. 
- به صورت ناهمزمان اجرا شده و باعث وقفه در پاسخ به کلاینت نمی‌شود.
### مثال
فرض کنید RF=3 و نودها: Node A، Node B و Node C.
۱. یک به‌روزرسانی رخ می‌دهد: 
داده روی Node A و Node B نوشته شده است. 
<div dir="rtl" align="right">

نود C آفلاین بوده و به‌روزرسانی را دریافت نکرده است.

۲. کلاینت خواندن را با سازگاری کوorum انجام می‌دهد:  

هماهنگ‌کننده داده کامل را از نود A می‌گیرد.  

Digest‌ها را از نودهای B و C می‌گیرد.

۳. ناسازگاری تشخیص داده می‌شود:  

Digest نود C با A و B متفاوت است.

۴. عملیات تعمیر خواندن اجرا می‌شود:  

هماهنگ‌کننده جدیدترین داده را از A یا B می‌گیرد.  

داده به نود C ارسال می‌شود تا اصلاح شود.  

کلاینت جدیدترین داده را دریافت می‌کند.

---

## 🌐 پروتکل گاسپ: همگام‌سازی وضعیت خوشه  

نودها هر ثانیه با ۱ تا ۳ نود تصادفی وضعیت خود را تبادل می‌کنند.  

از شماره نسل برای تشخیص راه‌اندازی مجدد استفاده می‌کند.  

نودهای Seed به نودهای جدید کمک می‌کنند به خوشه ملحق شوند.  

اطمینان می‌دهد همه نودها اطلاعات به‌روز دارند.

---

## ⏰ شناسایی خطا با آشکارساز خطای فی آکرول  

خطاهای نود را با سطوح شک تطبیقی شناسایی می‌کند (نه فقط زنده یا مرده).  

کاهش مثبت‌های کاذب ناشی از تأخیر شبکه.  

به تدریج نودهای کند یا خراب را منزوی می‌کند.

---

## ✍️ روند نوشتن در کاساندرا  

۱. نوشتن ابتدا به لاگ تعهد (Commit Log) روی دیسک افزوده می‌شود (برای دوام داده).  

۲. داده به جدول حافظه‌ای (MemTable) که ساختاری مرتب در حافظه است اضافه می‌شود.  

۳. وقتی جدول حافظه‌ای پر شد، به صورت یک جدول رشته‌ای مرتب (SSTable) غیرقابل تغییر روی دیسک ذخیره می‌شود.  

۴. عملیات ادغام (Compaction) دوره‌ای SSTable‌ها را ادغام و بهینه می‌کند.

---

## 📂 لاگ تعهد (Commit Log)  

لاگ پیش‌نویس نوشته شده روی دیسک.  

تضمین دوام داده در صورت کرش.  

نوشتن تا کامل شدن لاگ تعهد تأیید نمی‌شود.

---

## 🧠 جدول حافظه‌ای (MemTable)  

ذخیره‌سازی موقت و در حافظه.  

مرتب شده بر اساس کلید پارتیشن و ستون‌های خوشه‌ای.  

خواندن و نوشتن سریع.  

چندین جدول حافظه‌ای هنگام فلش شدن وجود دارد.

---

## 💽 جداول رشته‌ای مرتب (SSTables)  

فایل‌های غیرقابل تغییر روی دیسک پس از فلش جدول حافظه‌ای.  

شامل پارتیشن‌ها و ردیف‌های مرتب شده.  

به‌روزرسانی‌ها باعث ایجاد جدول رشته‌ای جدید می‌شوند؛ جداول قدیمی پس از ادغام حذف می‌شوند.

---

## 🗑️ حذف نرم (Tombstones)  

حذف‌ها با علامت حذف نرم (Tombstone) مشخص می‌شوند، نه حذف فوری.  

علامت‌های حذف پس از حدود ۱۰ روز (قابل تنظیم) منقضی می‌شوند.  

در ادغام حذف می‌شوند تا فضا آزاد شود.  

وجود زیاد حذف نرم باعث کندی خواندن و مصرف بیشتر فضا می‌شود.

---

## ⚡ خواندن داده در کاساندرا  

۱. بررسی کش ردیف (Row Cache) برای ردیف‌های پر استفاده.  

۲. در صورت عدم یافتن، بررسی فیلتر بلوم (Bloom filter) برای رد سریع جداول بدون داده.  

۳. استفاده از کش کلید (Key Cache) برای یافتن مکان پارتیشن.  

۴. جستجو در خلاصه اندیس پارتیشن و اندیس پارتیشن برای یافتن آفست داده.  

۵. خواندن از جدول حافظه‌ای و جداول رشته‌ای برای دریافت جدیدترین نسخه.

---

## 🌀 عملیات ادغام (Compaction)  

ادغام چند جدول رشته‌ای به یک جدول.  

حذف داده‌های قدیمی و علامت‌های حذف نرم.  

کاهش تعداد جداولی که باید خوانده شوند.  

استراتژی‌ها:  

- ادغام بر اساس اندازه (ادغام چندمرحله‌ای) — پیش‌فرض و مناسب برای حجم بالای نوشتن  
- ادغام سطح‌بندی شده — بهینه‌شده برای سرعت بالای خواندن  
- ادغام پنجره زمانی — مناسب داده‌های وابسته به زمان


---

## 🎯 مثال‌ها  

### مثال ۱: خواندن با سازگاری کوorum  

RF = ۳، W = ۲، R = ۲ (کوorum)  

نوشتن روی هر ۲ نود، خواندن از هر ۲ نود.  

تضمین می‌کند R + W > RF → سازگاری قوی.

### مثال ۲: سناریوی حذف نرم  

داده روی نود A (که خاموش است) حذف شده.  

نود B هنوز داده را دارد.  

علامت حذف نرم تضمین می‌کند وقتی نود A بازیابی و همگام‌سازی شود، داده حذف شده باز نگردد.

</div>

