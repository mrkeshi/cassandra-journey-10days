# روز هفتم - مدل‌سازی داده مبتنی بر کوئری در آپاچی کاساندرا

![لوگوی کاساندرا](https://img.shields.io/badge/Apache%20Cassandra-1287B1?style=flat&logo=apache-cassandra&logoColor=white)
[![لایسنس: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![ستاره‌های گیت‌هاب](https://img.shields.io/github/stars/mrkeshi/cassandra-journey-10days?style=social)](https://github.com/mrkeshi/cassandra-journey-10days)

به **روز هفتم** از سفر یادگیری آپاچی کاساندرا خوش آمدید! 🎉 امروز به موضوع **مدل‌سازی داده مبتنی بر کوئری** می‌پردازیم، اصلی که کاساندرا را از پایگاه‌داده‌های رابطه‌ای سنتی متمایز می‌کند. برخلاف پایگاه‌داده‌های رابطه‌ای که داده‌ها را نرمال‌سازی می‌کنند و جداول را بر اساس روابط طراحی می‌کنند، طراحی در کاساندرا حول کوئری‌هایی که قرار است اجرا شوند، می‌چرخد. این رویکرد عملکرد خواندن بسیار سریعی را تضمین می‌کند، اما نیاز به برنامه‌ریزی دقیق دارد. 🚀

در این راهنما، ما:
- اصول مدل‌سازی داده مبتنی بر کوئری را توضیح می‌دهیم 📝
- نحوه طراحی جداول بر اساس کوئری‌های اپلیکیشن را بررسی می‌کنیم 🛠️
- مثال‌های عملی و غیرتکراری برای یک اپلیکیشن شبکه اجتماعی ارائه می‌دهیم 📱
- بهترین روش‌ها و اشتباهات رایج را برجسته می‌کنیم ⚠️
- تمرین‌هایی برای آزمایش مهارت‌های شما ارائه می‌کنیم 🧠
- این موضوع را با مفاهیم روز ششم (TTL، ایندکس‌های ثانویه، توابع داخلی) پیوند می‌دهیم 🔗

بیایید این راهنما را جذاب، عملی و مناسب برای مبتدیان کنیم! 💪

---

## 📖 مقدمه‌ای بر مدل‌سازی داده مبتنی بر کوئری

در آپاچی کاساندرا، **مدل‌سازی داده** بر اساس کوئری‌هایی که اپلیکیشن شما نیاز به اجرا دارد، انجام می‌شود. برخلاف پایگاه‌داده‌های رابطه‌ای که جداول را برای جلوگیری از افزونگی طراحی می‌کنند و به JOINها وابسته‌اند، کاساندرا با **غیرنرمال‌سازی داده‌ها** و تنظیم جداول برای الگوهای کوئری خاص، اولویت را به **عملکرد خواندن** می‌دهد. این یعنی ابتدا باید کوئری‌های خود را تعریف کنید، سپس اسکیما را طوری طراحی کنید که این کوئری‌ها بهینه اجرا شوند.

### 🔑 اصول کلیدی
1. **غیرنرمال‌سازی (Denormalization)**:
   - کاساندرا از JOIN پشتیبانی نمی‌کند، بنابراین اغلب داده‌ها را در چندین جدول تکرار می‌کنید تا الگوهای مختلف کوئری را پشتیبانی کنید.
   - هدف: بهینه‌سازی برای **سرعت خواندن**، حتی اگر به معنای مصرف فضای ذخیره‌سازی بیشتر یا پیچیدگی در نوشتن باشد.

2. **طراحی برای خواندن، نه نوشتن**:
   - کاساندرا برای خواندن سریع بهینه شده است. ساختار جدول باید تعداد دسترسی‌های دیسک را به حداقل برساند و داده‌ها را از قبل برای کوئری‌های شما مرتب کند.
   - نوشتن در کاساندرا ارزان است، بنابراین نوشتن داده‌های یکسان در چندین جدول اشکالی ندارد.

3. **اول کوئری، سپس اسکیما**:
   - ابتدا کوئری‌های اپلیکیشن خود را مشخص کنید (مثلاً «دریافت همه پست‌های یک کاربر» یا «یافتن پست‌ها با یک هشتگ خاص»).
   - جداول را طوری طراحی کنید که این کوئری‌ها به‌صورت کارآمد اجرا شوند، با استفاده از **کلیدهای پارتیشن** و **کلیدهای مرتب‌سازی**.

4. **کلیدهای ترکیبی (Composite Keys)**:
   - از **کلیدهای پارتیشن** برای توزیع داده‌ها در نودها استفاده کنید.
   - از **کلیدهای مرتب‌سازی** برای مرتب کردن داده‌ها در یک پارتیشن برای بازیابی کارآمد استفاده کنید.

5. **ادغام با TTL** (از روز ششم):
   - از TTL برای داده‌های موقت (مثل پست‌های در حال انقضا یا اعلان‌ها) برای مدیریت بهینه فضای ذخیره‌سازی استفاده کنید.
   - مثال: استوری‌ها در یک اپلیکیشن شبکه اجتماعی که پس از 24 ساعت منقضی می‌شوند.

---

## 🛠️ بخش اول: درک طراحی مبتنی بر کوئری

بیایید فرآیند مدل‌سازی داده مبتنی بر کوئری را با یک سناریوی واقعی تجزیه کنیم: یک **پلتفرم شبکه اجتماعی**. کاربران می‌توانند محتوا ارسال کنند، دیگران را دنبال کنند و پست‌ها را بر اساس هشتگ‌ها یا دسته‌بندی‌ها مرور کنند. هدف ما طراحی جداولی است که کوئری‌های رایج را به‌صورت کارآمد پشتیبانی کنند.

### 📌 فرآیند گام‌به‌گام
1. **شناسایی کوئری‌ها**:
   - اپلیکیشن شما به چه داده‌هایی نیاز دارد؟
   - مثال: «نمایش همه پست‌های یک کاربر خاص، مرتب‌شده بر اساس زمان» یا «نمایش پست‌ها با یک هشتگ خاص».

2. **طراحی کلید اصلی**:
   - یک **کلید پارتیشن** انتخاب کنید تا داده‌ها را توزیع کند (مثلاً `user_id` برای کوئری‌های خاص کاربر).
   - **کلیدهای مرتب‌سازی** را برای مرتب کردن داده‌ها در یک پارتیشن اضافه کنید (مثلاً `created_at` برای مرتب‌سازی زمانی).

3. **غیرنرمال‌سازی برای الگوهای کوئری**:
   - برای هر الگوی کوئری اصلی، جدول جداگانه‌ای ایجاد کنید، حتی اگر به معنای تکرار داده‌ها باشد.
   - مثال: یک جدول برای پست‌های یک کاربر، جدول دیگر برای پست‌های یک هشتگ.

4. **بهینه‌سازی با TTL و ایندکس‌ها** (ارتباط با روز ششم):
   - از TTL برای داده‌های موقتی (مثل استوری‌ها یا اعلان‌ها) استفاده کنید.
   - از ایندکس‌های ثانویه به‌صورت محدود برای کوئری‌هایی که با ساختار کلید اصلی سازگار نیستند استفاده کنید (اما از استفاده بیش از حد به دلیل هزینه‌های عملکردی اجتناب کنید).

---

## 📚 بخش دوم: مثال عملی – پلتفرم شبکه اجتماعی

بیایید جداول را برای یک اپلیکیشن شبکه اجتماعی با کوئری‌های زیر طراحی کنیم:
1. **دریافت همه پست‌های یک کاربر خاص**، مرتب‌شده بر اساس زمان (جدیدترین ابتدا).
2. **دریافت همه پست‌ها با یک هشتگ خاص** (مثلاً #AI).
3. **دریافت پست‌های کاربرانی که یک نفر دنبال می‌کند** (فید کاربر).
4. **دریافت اعلان‌های یک کاربر**، که پس از 7 روز منقضی می‌شوند.

### 🎯 کوئری 1: پست‌های یک کاربر
**کوئری**:
```sql
SELECT * FROM posts_by_user WHERE user_id = 'ali123' ORDER BY created_at DESC;
```

**طراحی جدول**:
```cql
CREATE TABLE posts_by_user (
    user_id uuid,
    post_id uuid,
    title text,
    content text,
    created_at timeuuid,
    PRIMARY KEY (user_id, created_at)
) WITH CLUSTERING ORDER BY (created_at DESC);
```
- **کلید پارتیشن**: `user_id` (پست‌ها را بر اساس کاربر در نودها توزیع می‌کند).
- **کلید مرتب‌سازی**: `created_at` (پست‌ها را بر اساس زمان، از جدید به قدیم مرتب می‌کند).
- **چرا TimeUUID؟** تضمین می‌کند پست‌هایی که در یک زمان ایجاد شده‌اند، یکتا باشند (روز ششم: توابع داخلی).

**مثال درج**:
```cql
INSERT INTO posts_by_user (user_id, post_id, title, content, created_at)
VALUES (123e4567-e89b-12d3-a456-426614174000, uuid(), 'اولین پست من!', 'سلام دنیا!', now());
```

**مثال بازیابی**:
```cql
SELECT * FROM posts_by_user WHERE user_id = 123e4567-e89b-12d3-a456-426614174000;
```

### 🎯 کوئری 2: پست‌ها بر اساس هشتگ
**کوئری**:
```sql
SELECT * FROM posts_by_hashtag WHERE hashtag = '#AI' ORDER BY created_at DESC;
```

**طراحی جدول**:
```cql
CREATE TABLE posts_by_hashtag (
    hashtag text,
    created_at timeuuid,
    post_id uuid,
    user_id uuid,
    title text,
    content text,
    PRIMARY KEY (hashtag, created_at)
) WITH CLUSTERING ORDER BY (created_at DESC);
```
- **کلید پارتیشن**: `hashtag` (پست‌ها را بر اساس هشتگ گروه‌بندی می‌کند).
- **کلید مرتب‌سازی**: `created_at` (پست‌ها را به‌صورت زمانی مرتب می‌کند).
- **توجه**: داده‌های پست مشابه اینجا تکرار می‌شوند تا نیازی به JOIN نباشد.

**مثال درج** (پست مشابه بالا، تکرار شده برای هشتگ):
```cql
INSERT INTO posts_by_hashtag (hashtag, created_at, post_id, user_id, title, content)
VALUES ('#AI', now(), uuid(), 123e4567-e89b-12d3-a456-426614174000, 'اولین پست من!', 'سلام دنیا!');
```

### 🎯 کوئری 3: فید کاربر (پست‌های کاربران دنبال‌شده)
**کوئری**:
```sql
SELECT * FROM user_feed WHERE user_id = 'ali123' ORDER BY created_at DESC;
```

**طراحی جدول**:
```cql
CREATE TABLE user_feed (
    user_id uuid,
    created_at timeuuid,
    post_id uuid,
    poster_id uuid,
    title text,
    content text,
    PRIMARY KEY (user_id, created_at)
) WITH CLUSTERING ORDER BY (created_at DESC);
```
- **کلید پارتیشن**: `user_id` (کاربری که فید خود را مشاهده می‌کند).
- **کلید مرتب‌سازی**: `created_at` (پست‌ها را بر اساس زمان مرتب می‌کند).
- **منطق**: وقتی کاربری پستی ارسال می‌کند، پست در جدول `user_feed` برای همه دنبال‌کنندگان او درج می‌شود.

**مثال درج** (وقتی کاربر پستی ارسال می‌کند، برای دنبال‌کنندگان پخش می‌شود):
```cql
INSERT INTO user_feed (user_id, created_at, post_id, poster_id, title, content)
VALUES (follower_uuid, now(), uuid(), 123e4567-e89b-12d3-a456-426614174000, 'اولین پست من!', 'سلام دنیا!');
```

### 🎯 کوئری 4: اعلان‌ها با TTL
**کوئری**:
```sql
SELECT * FROM notifications WHERE user_id = 'ali123';
```

**طراحی جدول** (با TTL از روز ششم):
```cql
CREATE TABLE notifications (
    user_id uuid,
    notification_id uuid,
    created_at timeuuid,
    message text,
    PRIMARY KEY (user_id, created_at)
) WITH CLUSTERING ORDER BY (created_at DESC);
```
- **کلید پارتیشن**: `user_id`.
- **کلید مرتب‌سازی**: `created_at`.
- **TTL**: اعلان‌ها پس از 7 روز (604800 ثانیه) منقضی می‌شوند.

**مثال درج** (با TTL):
```cql
INSERT INTO notifications (user_id, notification_id, created_at, message)
VALUES (123e4567-e89b-12d3-a456-426614174000, uuid(), now(), 'شما یک دنبال‌کننده جدید دارید!')
USING TTL 604800;
```

**بازیابی با بررسی TTL** (روز ششم: توابع داخلی):
```cql
SELECT message, TTL(message) AS remaining_time FROM notifications WHERE user_id = 123e4567-e89b-12d3-a456-426614174000;
```

---

## ⚠️ بهترین روش‌ها و اشتباهات رایج

### ✅ باید‌ها
- **با کوئری‌ها شروع کنید**: همیشه ابتدا کوئری‌های اپلیکیشن خود را مشخص کنید.
- **از TimeUUID برای کلیدهای مبتنی بر زمان استفاده کنید**: از تداخل زمانی جلوگیری می‌کند (روز ششم).
- **از TTL برای داده‌های موقت استفاده کنید**: مناسب برای اعلان‌ها، استوری‌ها یا توکن‌های جلسه.
- **پارتیشن‌ها را قابل مدیریت نگه دارید**: از کلیدهای پارتیشن استفاده کنید که داده‌ها را به‌صورت یکنواخت توزیع کنند (مثلاً از استفاده از یک هشتگ مثل `#trending` برای همه پست‌ها اجتناب کنید).

### ❌ نباید‌ها
- **از ایندکس‌های ثانویه بیش از حد استفاده نکنید** (روز ششم): برای ستون‌های با کاردینالیتی بالا (مثل `user_id`) کند هستند. به‌جای آن از جداول اختصاصی استفاده کنید.
- **انتظار JOIN نداشته باشید**: داده‌ها را در جداول مختلف تکرار کنید تا الگوهای کوئری مختلف را پشتیبانی کنید.
- **اندازه پارتیشن را نادیده نگیرید**: پارتیشن‌های بزرگ (مثلاً میلیون‌ها ردیف برای یک `user_id`) می‌توانند عملکرد را کاهش دهند. به استفاده از باکتینگ فکر کنید (مثلاً `user_id, year_month` به‌عنوان کلید پارتیشن).

---

## 🧠 تمرین‌هایی برای آزمایش مهارت‌ها

1. **طراحی جدول**:
   - کوئری: «دریافت همه نظرات روی یک پست خاص، مرتب‌شده بر اساس زمان.»
   - وظیفه: دستور `CREATE TABLE` را بنویسید و یک نمونه کوئری `INSERT` و `SELECT` ارائه دهید.

2. **گسترش اپلیکیشن شبکه اجتماعی**:
   - کوئری: «دریافت همه پست‌هایی که یک کاربر خاص لایک کرده است.»
   - وظیفه: یک جدول طراحی کنید، انتخاب کلید اصلی خود را توضیح دهید و یک کوئری `INSERT` بنویسید.

3. **چالش TTL**:
   - سناریو: استوری‌ها در اپلیکیشن شبکه اجتماعی پس از 24 ساعت منقضی می‌شوند.
   - وظیفه: جدول `posts_by_user` را اصلاح کنید تا شامل یک فیلد بولین `story` باشد و TTL 24 ساعته فقط به استوری‌ها اعمال شود.

4. **پیشرفته**:
   - کوئری: «دریافت 10 پست اخیر در یک دسته‌بندی (مثلاً 'ورزش') از 7 روز گذشته.»
   - وظیفه: یک جدول طراحی کنید و توضیح دهید که چگونه با استفاده از `minTimeuuid` فیلتر زمانی را مدیریت می‌کنید (روز ششم).

لطفاً پاسخ‌های خود را به اشتراک بگذارید تا بررسی کنم! 😊 یا اگر به راهنمایی یا پاسخ نیاز دارید، بگویید.

---

## 🔗 ارتباط با روز ششم: TTL، ایندکس‌های ثانویه و توابع داخلی

- **TTL**: در جدول `notifications` برای حذف خودکار داده‌ها پس از 7 روز استفاده شده است تا فضای ذخیره‌سازی بهینه شود.
- **ایندکس‌های ثانویه**: اگر نیاز به کوئری پست‌ها بر اساس یک فیلد نادر (مثلاً `content` شامل یک کلمه کلیدی) دارید، می‌توانید از ایندکس ثانویه استفاده کنید، اما برای کوئری‌های مکرر بهتر است جدول جدید بسازید.
- **توابع داخلی**:
   - از `now()` و `uuid()` برای تولید شناسه‌های یکتا و زمان‌سنج‌ها استفاده شده است.
   - از `minTimeuuid` و `maxTimeuuid` برای کوئری‌های محدوده زمانی استفاده شده است (مثلاً پست‌ها از یک بازه زمانی خاص).

---

## ❓ سوالات متداول

**س: چگونه بدانم که برای یک داده به چندین جدول نیاز دارم؟**  
ج: اگر اپلیکیشن شما چندین الگوی کوئری دارد (مثلاً بر اساس کاربر، هشتگ یا دسته‌بندی)، برای هر الگو یک جدول بسازید. غیرنرمال‌سازی در کاساندرا این را انتظار دارد.

**س: آیا می‌توانم به‌جای چندین جدول از ایندکس‌های ثانویه استفاده کنم؟**  
ج: ایندکس‌های ثانویه (روز ششم) برای فیلدهای با کاردینالیتی پایین یا کوئری‌های نادر مفید هستند، اما برای کوئری‌های مکرر یا با کاردینالیتی بالا، جداول اختصاصی کارآمدترند.

**س: اگر دو پست در یک زمان `created_at` یکسان داشته باشند چه می‌شود؟**  
ج: به‌جای `timestamp` از `TimeUUID` استفاده کنید تا یکتایی تضمین شود، زیرا شامل یک شناسه یکتا است (روز ششم).

---

## 🚀 قدم بعدی چیست؟

فردا (روز هشتم)، ما به **ویژگی‌های پیشرفته کاساندرا** مانند نمای‌های مادی‌شده، عملیات دسته‌ای و تراکنش‌های سبک می‌پردازیم. این‌ها بر اساس مدل‌سازی مبتنی بر کوئری امروز، اپلیکیشن‌های شما را قدرتمندتر می‌کنند! منتظر باشید! 🌟

اگر سوالی دارید، می‌خواهید پاسخ تمرین‌هایتان بررسی شود یا به مثال‌های بیشتری نیاز دارید، به من بگویید! 😊

---
