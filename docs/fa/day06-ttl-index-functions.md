# روز ششم - تسلط بر TTL، ایندکس‌های ثانویه و توابع داخلی در آپاچی کاساندرا

![لوگوی کاساندرا](https://img.shields.io/badge/Apache%20Cassandra-1287B1?style=flat&logo=apache-cassandra&logoColor=white)
[![مجوز: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![ستاره‌های گیت‌هاب](https://img.shields.io/github/stars/mrkeshi/cassandra-journey-10days?style=social)](https://github.com/mrkeshi/cassandra-journey-10days)

به **روز ششم** از سفر یادگیری آپاچی کاساندرا خوش آمدید! 🎉 امروز به سه موضوع کلیدی می‌پردازیم: **TTL (زمان زنده ماندن)**، **ایندکس‌های ثانویه** و **توابع داخلی** در زبان پرس‌وجوی کاساندرا (CQL). این قابلیت‌ها به شما امکان می‌دهند تا انقضای داده‌ها را مدیریت کنید، روی ستون‌های غیرکلیدی پرس‌وجو کنید و از توابع قدرتمند برای کار با داده‌ها استفاده کنید. 🚀

تا حالا با مفاهیم پایه کاساندرا، نصب، پرس‌وجوهای CQL و مدل‌سازی داده آشنا شدید. در این راهنما، این موضوعات رو گام‌به‌گام با توضیحات ساده، مثال‌های عملی و تمرین‌هایی برای تثبیت یادگیری بررسی می‌کنیم. بیاید این مباحث رو جذاب و کاربردی کنیم! 💪

---

## 📖 مقدمه‌ای بر TTL، ایندکس‌های ثانویه و توابع داخلی

در ادامه یه مرور سریع از موضوعات امروز داریم:

- **TTL (زمان زنده ماندن)**: مشخص می‌کنه یه داده (ستون یا سلول) تا چه مدت تو کاساندرا معتبره و بعدش به‌صورت خودکار حذف می‌شه. برای داده‌های موقت مثل کدهای OTP یا توکن‌های جلسه عالیه.
- **ایندکس ثانویه**: به شما امکان می‌ده روی ستون‌هایی که کلید اصلی نیستن پرس‌وجو کنید، ولی باید مراقب کارایی باشید.
- **توابع داخلی**: CQL توابعی مثل `TTL()`، `WRITETIME()`، `now()` و `count()` داره که برای کار با متادیتا یا محاسبات به کار می‌رن.

تو این راهنما:
- هر مفهوم رو با جزئیات ساده و قابل فهم توضیح می‌دیم 📝
- مثال‌های عملی با سناریوهای واقعی ارائه می‌کنیم 🛠️
- بهترین روش‌ها و محدودیت‌ها رو مشخص می‌کنیم ⚠️
- تمرین‌هایی برای تست دانش شما می‌ذاریم 🧠
- به سوالات رایج (مثل «TTL برای سطره یا ستون؟») جواب می‌دیم

بیاید شروع کنیم! 🚀

---

## 🔑 بخش اول: TTL (زمان زنده ماندن) – مدیریت انقضای داده‌ها

### ❓ TTL چیه؟

TTL (زمان زنده ماندن) تو کاساندرا مشخص می‌کنه یه داده (یه ستون یا سلول) تا چه مدت تو دیتابیس می‌مونه. بعد از تموم شدن TTL، کاساندرا داده رو به‌عنوان *tombstone* علامت‌گذاری می‌کنه و طی فرآیند فشرده‌سازی (compaction) حذفش می‌کنه.

### 🎯 چرا TTL مهمه؟

TTL برای این موارد خیلی کاربردیه:
- **پاک‌سازی خودکار**: حذف داده‌های موقت مثل کدهای OTP، توکن‌های جلسه یا نتایج کش‌شده.
- **بهینه‌سازی فضای ذخیره‌سازی**: جلوی رشد بی‌رویه دیتابیس رو می‌گیره.
- **موارد استفاده**: اعلان‌های موقت، جلسات کاربری یا داده‌های تبلیغاتی.

### 🛠️ مثال‌های عملی

بیاید با یه جدول نمونه برای ذخیره کدهای تأیید ورود کار کنیم.

#### 📦 تعریف جدول

```sql
CREATE TABLE login_codes (
    phone TEXT PRIMARY KEY,
    code TEXT
);
```

#### ✅ مثال ۱: درج ردیف با TTL

یه کد تأیید رو وارد می‌کنیم که بعد از ۵ دقیقه (۳۰۰ ثانیه) منقضی بشه.

```sql
INSERT INTO login_codes (phone, code)
VALUES ('09123456789', '8293')
USING TTL 300;
```

**چی داره اتفاق می‌افته؟**
- این ردیف (`phone`, `code`) بعد از ۳۰۰ ثانیه به‌صورت خودکار حذف می‌شه.
- برای سیستم‌های کد یک‌بارمصرف (OTP) عالیه.

#### ✅ مثال ۲: آپدیت ستون با TTL

کد مربوط به یه شماره تلفن رو با TTL جدید ۱۰ دقیقه (۶۰۰ ثانیه) آپدیت می‌کنیم.

```sql
UPDATE login_codes
USING TTL 600
SET code = '5932'
WHERE phone = '09123456789';
```

**چی داره اتفاق می‌افته؟**
- فقط ستون `code` یه TTL به مدت ۶۰۰ ثانیه می‌گیره.
- ستون `phone` (کلید اصلی) تحت تأثیر قرار نمی‌گیره.

#### ✅ مثال ۳: تنظیم TTL پیش‌فرض برای جدول

یه جدول برای فایل‌های موقت می‌سازیم که TTL پیش‌فرض ۲۴ ساعت (۸۶۴۰۰ ثانیه) داره.

```sql
CREATE TABLE temp_files (
    id UUID PRIMARY KEY,
    filename TEXT,
    uploaded_at TIMESTAMP
)
WITH default_time_to_live = 86400;
```

**چی داره اتفاق می‌افته؟**
- هر ردیفی که تو این جدول وارد بشه، بعد از ۲۴ ساعت منقضی می‌شه، مگر اینکه TTL جداگونه‌ای مشخص کنید.
- برای متادیتای فایل‌های موقت یا لاگ‌ها خیلی مناسبه.

#### ✅ مثال ۴: بررسی زمان باقی‌مانده TTL

زمان باقی‌مانده TTL یه ستون خاص رو چک می‌کنیم.

```sql
SELECT TTL(code)
FROM login_codes
WHERE phone = '09123456789';
```

**خروجی مورد انتظار**:
- اگه ۱۰۰ ثانیه باقی مونده باشه، خروجی `100` خواهد بود.

#### ✅ مثال ۵: TTL روی ستون‌های خاص

یه ردیف وارد می‌کنیم که فقط بعضی ستون‌ها TTL داشته باشن.

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY,
    name TEXT,
    email TEXT
);

INSERT INTO users (id, name, email)
VALUES (uuid(), 'Alireza', 'ali@example.com')
USING TTL 300;
```

**چی داره اتفاق می‌افته؟**
- هر دو ستون `name` و `email` یه TTL به مدت ۳۰۰ ثانیه می‌گیرن.
- حالا فقط ستون `email` رو آپدیت می‌کنیم:

```sql
UPDATE users
USING TTL 600
SET email = 'kos@gmail.com'
WHERE id = <your-uuid>;
```

**نتیجه**:
- ستون `email` حالا TTL ۶۰۰ ثانیه داره.
- ستون `name` TTL اصلی خودش (۳۰۰ ثانیه) رو نگه می‌داره.

### 🧠 نکته کلیدی: TTL در سطح ستونه

- TTL در کاساندرا در **سطح ستون (سلول)** اعمال می‌شه، نه کل سطر.
- فقط ستون‌هایی که تو دستور `INSERT` یا `UPDATE` مقداردهی می‌شن، TTL رو می‌گیرن.
- اگه می‌خوای کل سطر منقضی بشه، باید همه ستون‌های غیرکلیدی رو تو دستور با TTL مقداردهی کنی.

### ⚠️ بهترین روش‌ها و محدودیت‌ها

- **استفاده از TTL برای داده‌های موقت**: برای داده‌های دائمی از TTL استفاده نکنید.
- **اجتناب از TTL خیلی کوتاه**: TTLهای خیلی کوتاه (مثل کمتر از ۱۰ ثانیه) می‌تونن تعداد زیادی tombstone ایجاد کنن و کارایی رو کاهش بدن.
- **نظارت بر tombstoneها**: داده‌های منقضی‌شده به tombstone تبدیل می‌شن که طی فشرده‌سازی پاک می‌شن. تنظیمات فشرده‌سازی رو درست کنید.
- **TTL پیش‌فرض**: برای جدول‌هایی با نیازهای انقضای مشخص، از `default_time_to_live` استفاده کنید.

---

## 🔑 بخش دوم: ایندکس‌های ثانویه – پرس‌وجو روی ستون‌های غیرکلیدی

### ❓ ایندکس ثانویه چیه؟

تو کاساندرا، پرس‌وجوها معمولاً فقط روی **کلید اصلی** یا **کلید پارتیشن** قابل اجرا هستن تا کارایی بالا بمونه. **ایندکس ثانویه** به شما امکان می‌ده روی ستون‌های غیرکلیدی هم پرس‌وجو کنید، ولی یه سری ملاحظات داره.

### 🎯 چرا از ایندکس‌های ثانویه استفاده کنیم؟

- **انعطاف‌پذیری در پرس‌وجو**: می‌تونید روی ستون‌هایی مثل شهر یا ایمیل فیلتر کنید.
- **موارد استفاده**: فیلتر کردن کاربران بر اساس شهر، ایمیل یا ویژگی‌های دیگه.

### ⚠️ هشدار

- ایندکس‌های ثانویه برای ستون‌های با **کاردینالیتی بالا** (مثل `email` که مقادیر منحصربه‌فرد زیادی داره) یا دیتابیس‌های خیلی بزرگ مناسب نیستن.
- می‌تونن تو محیط‌های توزیع‌شده باعث کاهش کارایی بشن چون نیاز به اسکن چند گره دارن.

### 🛠️ مثال‌های عملی

بیاید یه جدول `users` بسازیم و ایندکس ثانویه روش اعمال کنیم.

#### 📦 تعریف جدول

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY,
    name TEXT,
    email TEXT,
    city TEXT
);
```

#### ✅ مثال ۱: ساخت ایندکس ثانویه

یه ایندکس روی ستون `city` می‌سازیم تا بتونیم بر اساس شهر پرس‌وجو کنیم.

```sql
CREATE INDEX ON users (city);
```

#### ✅ مثال ۲: پرس‌وجو با ایندکس ثانویه

حالا می‌تونید بر اساس `city` پرس‌وجو کنید، بدون اینکه جزو کلید اصلی باشه.

```sql
SELECT * FROM users WHERE city = 'Tehran';
```

**چی داره اتفاق می‌افته؟**
- ایندکس ثانویه این پرس‌وجو رو ممکن می‌کنه، وگرنه خطا می‌داد.
- بدون ایندکس، خطای زیر رو می‌گیرید: `InvalidQueryException: Cannot execute this query as it might involve data from multiple partitions`.

#### ✅ مثال ۳: پرس‌وجو بدون ایندکس (مورد خطا)

اگه بخواید بدون ایندکس روی `city` پرس‌وجو کنید:

```sql
SELECT * FROM users WHERE city = 'Tehran';
```

**خروجی مورد انتظار**:
- خطا: `InvalidQueryException: No secondary index found for column city`.

#### ✅ مثال ۴: حذف ایندکس ثانویه

اگه دیگه به ایندکس نیازی ندارید:

```sql
DROP INDEX users_city_idx;
```

### 🧠 بهترین روش‌ها برای ایندکس‌های ثانویه

- **استفاده محدود**: برای کارایی بهتر، از پرس‌وجوهای مبتنی بر کلید پارتیشن استفاده کنید.
- **کاردینالیتی پایین**: ایندکس‌های ثانویه رو برای ستون‌هایی با مقادیر منحصربه‌فرد کم (مثل `city`) استفاده کنید، نه `email`.
- **جایگزین‌ها**: برای پرس‌وجوهای پیچیده تو دیتابیس‌های بزرگ، از **نمایش‌های مادی (Materialized Views)** یا جدول‌های غیرنرمال‌شده استفاده کنید.
- **نظارت بر کارایی**: ایندکس‌های ثانویه می‌تونن روی سرعت نوشتن و خوندن تو خوشه‌های بزرگ تأثیر منفی بذارن.

---

## 🔑 بخش سوم: توابع داخلی در CQL

### ❓ توابع داخلی چی‌ان؟

کاساندرا یه سری توابع داخلی تو CQL داره که برای دستکاری داده‌ها، گرفتن متادیتا یا انجام محاسبات استفاده می‌شن. این توابع برای پرس‌وجوهای پویا و دیباگ کردن خیلی کاربردین.

### 📌 توابع داخلی رایج

| تابع                | توضیح                                              | مثال                                      |
|---------------------|--------------------------------------------------|------------------------------------------|
| `TTL(column)`       | زمان باقی‌مانده TTL یه ستون (به ثانیه) رو برمی‌گردونه | `SELECT TTL(code) FROM login_codes`      |
| `WRITETIME(column)` | زمان ثبت یا آپدیت یه ستون رو برمی‌گردونه         | `SELECT WRITETIME(name) FROM users`      |
| `now()`             | یه UUID مبتنی بر زمان تولید می‌کنه                | `INSERT INTO users (id) VALUES (now())`  |
| `toTimestamp(uuid)` | یه UUID رو به timestamp تبدیل می‌کنه              | `SELECT toTimestamp(now())`              |
| `count(*)`          | تعداد ردیف‌های نتیجه یه پرس‌وجو رو می‌شماره      | `SELECT count(*) FROM users`             |
| `dateOf(uuid)`      | تاریخ رو از یه UUID مبتنی بر زمان استخراج می‌کنه  | `SELECT dateOf(id) FROM users`           |

### 🛠️ مثال‌های عملی

#### ✅ مثال ۱: بررسی زمان ثبت

زمان آخرین آپدیت ستون `email` یه کاربر رو چک می‌کنیم.

```sql
SELECT WRITETIME(email)
FROM users
WHERE id = <your-uuid>;
```

**خروجی مورد انتظار**:
- یه timestamp مثل `2025-08-03 13:01:23.123+0000`.

#### ✅ مثال ۲: شمارش ردیف‌ها

تعداد کل کاربران رو می‌شمریم.

```sql
SELECT count(*)
FROM users;
```

**خروجی مورد انتظار**:
- یه عدد، مثلاً `42`.

#### ✅ مثال ۳: تولید UUID با `now()`

یه کاربر جدید با UUID مبتنی بر زمان وارد می‌کنیم.

```sql
INSERT INTO users (id, name)
VALUES (now(), 'Ali');
```

**چی داره اتفاق می‌افته؟**
- تابع `now()` یه UUID منحصربه‌فرد بر اساس زمان فعلی تولید می‌کنه.

#### ✅ مثال ۴: استخراج تاریخ از UUID

تاریخ رو از یه UUID مبتنی بر زمان می‌گیریم.

```sql
SELECT dateOf(id)
FROM users
WHERE id = <your-uuid>;
```

**خروجی مورد انتظار**:
- یه تاریخ مثل `2025-08-03`.

### 🧠 بهترین روش‌ها برای توابع داخلی

- **استفاده برای متادیتا**: توابعی مثل `TTL()` و `WRITETIME()` برای دیباگ یا ممیزی عالی‌ان.
- **ترکیب با پرس‌وجوها**: از `count(*)` یا `now()` تو منطق برنامه برای عملیات پویا استفاده کنید.
- **اجتناب از استفاده بیش‌ازحد**: توابعی مثل `count(*)` تو جدول‌های بزرگ می‌تونن کند باشن اگه پارتیشن‌بندی درست نباشه.

---

## 🧪 تمرین: دانش خودتون رو تست کنید

بیاید با یه تمرین عملی دانش‌تون رو محک بزنید.

### 📝 وظیفه: ساخت جدول اعلان‌ها با TTL

یه جدول به اسم `notifications` بسازید که پیام‌های موقتی رو ذخیره کنه و بعد از ۱ ساعت (۳۶۰۰ ثانیه) منقضی بشن. بعد یه اعلان نمونه وارد کنید.

#### 📦 تعریف جدول

```sql
CREATE TABLE notifications (
    id UUID PRIMARY KEY,
    user_id UUID,
    message TEXT
);
```

#### ✅ وظیفه شما

یه پرس‌وجوی CQL بنویسید که یه اعلان رو وارد کنه و بعد از ۱ ساعت منقضی بشه.

**جواب شما**:

```sql
INSERT INTO notifications (id, user_id, message)
VALUES (now(), uuid(), 'سفارشتون ارسال شد!')
USING TTL 3600;
```

**چی داره اتفاق می‌افته؟**
- تابع `now()` یه UUID مبتنی بر زمان برای `id` تولید می‌کنه.
- تابع `uuid()` یه UUID تصادفی برای `user_id` تولید می‌کنه.
- ستون `message` بعد از ۳۶۰۰ ثانیه (۱ ساعت) منقضی می‌شه.

#### ✅ وظیفه اضافی

زمان باقی‌مانده TTL ستون `message` اعلانی که وارد کردید رو چک کنید.

**جواب شما**:

```sql
SELECT TTL(message)
FROM notifications
WHERE id = <your-uuid>;
```

---

## 🧠 تمرین‌های اضافی

۱. **چالش TTL**: یه جدول برای جلسات کاربری موقت با TTL پیش‌فرض ۳۰ دقیقه بسازید. یه جلسه وارد کنید و TTLش رو بررسی کنید.
۲. **چالش ایندکس ثانویه**: یه ایندکس ثانویه روی ستون `user_id` جدول `notifications` اضافه کنید. یه پرس‌وجو بنویسید که همه اعلان‌های یه `user_id` خاص رو پیدا کنه.
۳. **چالش توابع**: یه پرس‌وجو بنویسید که هم `WRITETIME` و هم `dateOf` ستون `message` تو جدول `notifications` رو برگردونه.

---

## ⚠️ مشکلات رایج و بهترین روش‌ها

- **TTL**:
  - برای داده‌های دائمی از TTL استفاده نکنید؛ برای داده‌های موقت مناسبه.
  - از TTLهای خیلی کوتاه (مثل کمتر از ۱۰ ثانیه) پرهیز کنید چون tombstoneهای زیادی تولید می‌کنن.
- **ایندکس‌های ثانویه**:
  - روی ستون‌های با کاردینالیتی بالا (مثل `email` یا `timestamp`) استفاده نکنید.
  - برای پرس‌وجوهای پیچیده تو دیتابیس‌های بزرگ، از نمایش‌های مادی یا جدول‌های غیرنرمال‌شده استفاده کنید.
- **توابع داخلی**:
  - از `count(*)` تو جدول‌های بزرگ با احتیاط استفاده کنید تا کارایی کاهش پیدا نکنه.
  - از `now()` و `toTimestamp()` برای عملیات مبتنی بر زمان استفاده کنید.

---

## 🚀 قدم بعدی چیه؟

فردا به **نمایش‌های مادی (Materialized Views)** و **عملیات دسته‌ای (Batch Operations)** می‌پردازیم تا مهارت‌های مدل‌سازی داده و پرس‌وجوی شما رو به سطح بعدی ببریم! برای مثال‌های عملی و تمرین‌های بیشتر همراه باشید. 🎉

اگه سوال دارید یا مثال‌های بیشتری می‌خواید، بهم بگید تا محتوا رو براتون شخصی‌سازی کنم! 💬